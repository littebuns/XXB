## 复用类
Java中所有的事物都是围绕着类展开的。可以通过创建新类来复用代码，而不必重头开始编写。
复用代码核心在于使用类而不破坏现有的程序代码。一般有两种方式：组合和继承。

组合：在新类中产生现有类的对象。由于新的类是由现有类的对象所组成的，所以称为组合。
该方法只是复用了现有程序代码的功能，而非形式。

继承：按照现有类的形式创建新类，无需改变现有类的形式，采用现有类的形式并在其中添加新代码。



### 7.2 继承语法
继承是所有OOP语言中不可缺少的部分。当创建一个类时，总是在继承。（如果没有明确指定从哪个类继承，则隐式地从根类Object进行继承）

继承是一种特殊的语法，通过extends实现。这么做之后，会自动获得基类的所有域和方法。示例:Detergent.java



#### 7.2.1 初始化基类


#### 无参构造器
创建一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与我们用基类直接创建的对象是一样的。
二者的区别在于，后者来自于外部，而基类的子对象被包装在导出类的对象内部。

对于基类子对象的正确初始化有且只有一种方式：在构造器中调用基类的构造器来执行初始化。
Java会自动在导出类的构造器中插入对基类构造器的调用

示例：Cartoon.java

#### 有参构造器


如果没有默认的基类构造器或者想调用一个带参数的基类构造器，就必须使用关键字super显式的调用基类构造器的语句。

示例：Chess.java


### 7.3 代理
第三种称为代理(没有直接支持)，是继承与组合之间的中庸之道。
因为我们将一个成员对象置于要构造的类中(组合),与此同时，我们在新类中暴露了该成员对象的所有方法(继承)

### 7.4 结合使用组合和继承
一般而言，我们会同时使用组合和继承，并配以必要的构造器来初始化来创建更加复杂的类

#### 7.4.1 确保正确清理
C++中有析构函数(在对象被销毁的时候可以被自动调用的函数)。
Java中存在垃圾回收器(在必要的时候释放对象的内存),导致我们习惯于忘掉而不是销毁对象。

有时候类可能在生命周期中执行一些必需的清理活动，因为我们不清楚gc是什么时候会被调用，所以我们想要某个类清理一些东西，
就必须显式地编写一个特殊的方法来做这件事。
将这清理动作置于finally语句中，以预防异常的出现。

#### 7.4.2 名称屏蔽
如果Java的基类拥有某个被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本。
因此，无论是在该层或者是它的基类中对方法进行定义，重载机制都可以正常工作。


### 7.5 在组合与继承之间选择
Car.java
组合和继承都允许在新的类中放置子对象，组合是显式的这么做，而继承是隐式的这么做

组合技术一般用于想在新类中使用现有类的功能而非它的接口这种情况。即，在新类中嵌入某个对象，让其去实现功能。
但新类用户看到的只是为新类定义的接口，而不是嵌入对象的接口。

使用继承就是用某个现有类来开发它的一个特殊版本。通常情况下是在使用一个通用类并让其特殊化。
我们用交通工具来构建一个Car是不合理的，因为Car的组成部分并没有交通工具。
is-a (是一个) 的关系用继承
has-a (有一个) 的关系用组合

### 7.6 protected 关键字
Orc.java
有了继承,protected就具有了意义。理想中，private就够用了。但在实际项目中，经常想将某些事务隐藏起来但仍然允许导出类的成员来访问它们。
protected就是这个作用，对于类用户而言，这是private.对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它是可以访问的。(protected也提供了包内访问权限)

### 7.7 向上转型
为新类提供方法并不是继承技术最重要的部分，而是用来表现新类与基类之间的关系。（新类是基类的一种类型）
这不是编程中的东西，是语言的一部分。比如一个基类是Instrument（乐器）,Guitar为导出类。
由于继承可以确保基类中所有的方法在导出类中生效，所以能够向基类发送的所有信息同样也可以向导出类发送，这意味这Guitar对象也是一种类型的Instrument,即吉他是一种乐器。

#### 7.7.2 再论组合与继承
在面向对象编程中，一般而言我们都是直接将数据和方法包装到一个类中，并使用该类的对象，也可以使用组合技术使用现有类来开发新的类，而继承技术不太常用
使用继承，我们需要考虑是否需要从新类向基类进行向上转型，如果需要向上转型则继承是必要的。

### 7.8 final关键字
java中的final通常是指""这是无法改变的"。
不想做改变的原因有两种:设计和效率

#### 7.8.1 final数据
final能告诉编译器，这一块数据是恒定不变的 ，有时候恒定不变的数据是很有用的。
- 一个永不改变的编译时常量
- 一个在运行时被初始化的值，而你不希望它被改变
在Java中这类常量必须是基本数据类型，并且以关键字final表示，在对这个常量进行定义的时候，必须对其进行赋值

当是引用类型的时候运用final，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象，然而对象其自身是可以被修改的。

#### 空白final
Java允许生成 "空白fianl"， 即被声明为final但又未给定初值的域。
无论什么情况，编译器都要保证空白final在使用前必须被初始化。
空白final的出现可以做到根据对象而有所不同，却又保持其恒定不变的特性。

#### final参数
Java允许在参数列表中以声明的方式将参数指明为final，这意味着无法在方法中更改参数引用所指向的对象。